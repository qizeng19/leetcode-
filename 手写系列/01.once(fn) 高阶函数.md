手写一个 once(fn) 高阶函数，让传入函数只执行一次，并返回第一次的返回值。

好的，这是一个很经典的 JavaScript 高阶函数面试题。

下面是 `once` 函数的实现：

```javascript
/**
 * 创建一个只执行一次的函数。
 * 无论调用多少次，传入的 fn 都只会在第一次调用时执行，
 * 并且后续所有调用都会返回第一次执行的结果。
 *
 * @param {Function} fn - 需要被限制执行一次的函数。
 * @returns {Function} - 一个新的函数，它包装了原始函数。
 */
function once(fn) {
  let hasBeenCalled = false;
  let result;

  // 返回一个新的包装函数
  return function (...args) {
    // 检查是否已经被调用过
    if (!hasBeenCalled) {
      hasBeenCalled = true;
      // 关键：使用 .apply(this, args) 来确保
      // 1. fn 内部的 'this' 指向正确
      // 2. fn 接收到所有传入的参数
      result = fn.apply(this, args);
    }

    // 无论是第几次调用，都返回第一次的结果
    return result;
  };
}
```

---

### 🔍 工作原理解析

这个实现主要利用了 JavaScript 的 **闭包（Closure）** 特性：

1.  **高阶函数**：`once` 是一个高阶函数，因为它接受一个函数 (`fn`) 作为参数，并返回一个新的函数。
2.  **闭包**：返回的新函数（匿名函数 `function(...args)`）可以访问其外部函数 `once` 作用域中的变量，即 `hasBeenCalled` 和 `result`。这两个变量对于所有调用都是共享的。
3.  **状态锁（Flag）**：`hasBeenCalled` 变量充当一个“锁”或“标志”。它初始化为 `false`。
4.  **首次调用**：
    - 当返回的函数 _第一次_ 被调用时，`!hasBeenCalled` 为 `true`。
    - 程序进入 `if` 块。
    - `hasBeenCalled` 被立即设置为 `true`，"关上大门"。
    - 原始函数 `fn` 被执行。我们使用 `fn.apply(this, args)` 来确保 `fn` 内部的 `this` 上下文和所有传入的参数 (`...args`) 都能被正确传递。
    - `fn` 的返回值被存储在 `result` 变量中。
5.  **后续调用**：
    - 从第二次调用开始，`!hasBeenCalled` 为 `false`。
    - `if` 块被跳过。
    - `fn` 不会再次执行。
    - 函数直接返回先前存储在 `result` 变量中的值。

---

### 🚀 使用示例

你可以像这样使用它：

```javascript
// 1. 创建一个模拟的计算函数
function heavyCalculation(a, b) {
  console.log("...正在执行昂贵的计算...");
  return a + b;
}

// 2. 使用 once 包装它
const calculateOnce = once(heavyCalculation);

// 3. 多次调用
console.log("第一次调用:");
const result1 = calculateOnce(5, 10);
console.log("Result 1:", result1); // 输出 15

console.log("\n第二次调用:");
const result2 = calculateOnce(20, 30); // 注意：参数不同
console.log("Result 2:", result2); // 仍然输出 15

console.log("\n第三次调用:");
const result3 = calculateOnce(1, 1);
console.log("Result 3:", result3); // 仍然输出 15
```

**示例输出：**

```
第一次调用:
...正在执行昂贵的计算...
Result 1: 15

第二次调用:
Result 2: 15

第三次调用:
Result 3: 15
```

如你所见，"昂贵的计算" 日志只打印了一次，并且后续所有调用（即使参数不同）也都返回了第一次计算的结果 `15`。
